// -----------------------------------------------------------------------------
//  Programing links

8080 opcodes:
file:///Users/dthurston/Projects/arduino/Altair101/documents/8080opcodes.txt

// -----------------------------------------------------------------------------
  Bitwise, shift right:
    https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitshiftright/
  Exclusive or (XOR):
    https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwisexor/

// -----------------------------------------------------------------------------
// Sample loop

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:       ; Start
  //
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //
  0041, 0000, 0000, // lxi h,Start  ; lxi_HL lb hb. Load into register H:L = 0000:0000.
  0176,             // mov M      ; Move the data in register M(register address H:L), to register A.
  0006, 0001,       // mvi b,1    ; Move db to register B.
  0016, 0002,       // mvi c,2    ; Move db to register C.
  0127,             // mov d,a    ; Move register a to register D.
  0036, 0003,       // mvi e,3    ; Move db to register E.
  //
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //                //            ; --------------------------------------
  //                // LOOP:      ; Change values and loop.
  0043,             // inx M      ; Increment register M(register address H:L).
  0176,             // mov M      ; Move the data in register M(register address H:L), to register A.
  0343, 38,         // out 38     ; Print the registers.
  0166,             // hlt
  0303, 14, 0000,   // jmp        ; Jump to LOOP.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
//  Opcode Test Programs
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Test opcode ldax.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Test opcode ldax.
  //                //            ; Load register A with data value from address B:C or D:E.
  //
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //
  B00111110, 6,     // mvi a,6    ; Move # to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,0
  B00101110, 5,     // mvi l,0
  //
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  // ldax RP  00RP1010 - Load register A with indirect through BC(RP=00) or DE(RP=01)
  // ---------------
  //  case B00001010:
  //
  B00000110, 0,     // mvi b,0    ; Set registers, then move data to register A.
  B00001110, 1,     // mvi c,1    ; B:C data = 6
  B00001010,        // ldax b
  0343, 37,         // out 37     ; Print register A.
  //
  B00010110, 0,     // mvi d,0
  B00011110, 6,     // mvi e,6    ; D:E data = B00010110 = 22
  B00011010,        // ldax d
  0343, 37,         // out 37     ; Print register A.
  //
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  0303, 0000, 0000, // jmp Start    ; Jump back to beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// Test opcode xra.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Test opcode xra. Register exclusive OR with register with A.
  //
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //
  B00111110, 6,     // mvi a,6    ; Move # to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,4
  B00101110, 5,     // mvi l,5
  //
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  //                        xra R    10 101 SSS  Register exclusive OR with register with A.
  //
  B00111110, 6,     // mvi a,6    ; Set register A, then do the exclusive OR.
  B10101000,        // xra b
  B00111110, 6,     // mvi a,6
  B10101001,        // xra c
  B00111110, 6,     // mvi a,6
  B10101010,        // xra d
  B00111110, 6,     // mvi a,6
  B10101011,        // xra e
  B00111110, 6,     // mvi a,6
  B10101100,        // xra h
  B00111110, 6,     // mvi a,6
  B10101101,        // xra l
  //
  0343, 38,         // out 38     ; Print the updated register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  0303, 0000, 0000, // jmp Start    ; Jump back to beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// Test opcode lxi.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Test opcode lxi. Load register pair immediate.
  //                              ; Move a(hb:lb) into register pair RP, example, B:C = hb:lb.
  //
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //
  B00111110, 6,     // mvi a,6    ; Move # to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,4
  B00101110, 5,     // mvi l,5
  //
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  //
  B00000001, 0002,0001, // lxi b,513  ; lxi b,16-bit-address: 00 000 010 : 00 000 001 = 002 : 001
  B00010001, 0004,0021, // lxi d,1041 ; lxi b,16-bit-address. 00 000 100 : 00 010 001 = 004 : 021
  B00100001, 0006,0041, // lxi h,1569 ; lxi b,16-bit-address. 00 000 110 : 00 100 001 = 010 : 041
  //
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  0303, 0000, 0000, // jmp Start    ; Jump back to beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// Test opcodes sta and lda.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Test opcodes sta and lda.
  //
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //1RRR110
  B00111110, 6,     // mvi a,0    ; Move # to register A.
  //
  B00100110, 0,     // mvi h,0    ; Address for memory address testing.
  B00101110, 60,    // mvi l,60
  //
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  //
  B00111110, 6,     // mvi a,0    ; Move # to register A.
  0343, 37,         // out 37     ; Print register A.
  //
  0000,             // nop
  B00110010, 60, 0, // sta 60     ; Store register A's data to the address(hb:lb).
  0343, 36,         // out 36     ; Print memory address data value. "36" prints the register pair H:L and data at the address.
  //
  0000,             // nop
  B00111110, 0,     // mvi a,0    ; Move # to register A.
  B00111010, 60, 0, // lda 60     ; Load register A from the address(hb:lb).
  0343, 37,         // out 37     ; Print register A.
  //
  0166,             // hlt
  //
  // -----------------------------------------------------------------------------
  0303, 0000, 0000, // jmp Start    ; Jump back to beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// INR: Increment opcode test.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Testing opcodes inr and dcr.
  // ------------------------------------------------------------------------------------------
  //                //            ; Intialize register values.
  //1RRR110
  B00111110, 6,     // mvi a,6    ; Move # to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,4
  B00101110, 5,     // mvi l,5
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  //0DDD100
  B00111100,        // inr a      ; Increment the register
  B00000100,        // inr b 
  B00001100,        // inr C
  B00010100,        // inr D
  B00011100,        // inr E
  B00100100,        // inr H
  B00101100,        // inr L
  0343, 38,         // out 38     ; Print the incrmented register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  //0DDD101
  B00111101,        // dcr a      ; Decrement the register
  B00000101,        // dcr b 
  B00001101,        // dcr C
  B00010101,        // dcr D
  B00011101,        // dcr E
  B00100101,        // dcr H
  B00101101,        // dcr L
  0343, 38,         // out 38     ; Print the decremented register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  0303, 0000, 0000, // jmp Start    ; Jump to the beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // Start:     ; Start: Testing opcodes mvi, mov, inr.
  //                              ;   Also uses: lxi, OUT, hlt.
  //
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  //                //            ; Intialize register values.
  //
  //1RRR110
  B00111110, 6,     // mvi a,6    ; Move # to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,4
  B00101110, 5,     // mvi l,5
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  // mov d,S  01 DDD SSS   Move register to a register. 36 register to register combinations.
  //                 111 A
  //                 000 B
  //                 001 C
  //                 010 D
  //                 011 E
  //                 100 H
  //                 101 L
  //
  //1RRR110
  B00111110, 7,     // mvi a,7    ; Move # to register A.
  //1DDDSSS
  B01000111,        // mov b,a    ; 01 000 111  ; Move register a to each register.
  B00111100,        // inr a      ; Increment the register
  B01001111,        // mov c,a    ; 01 001 111
  B00111100,        // inr A
  B01010111,        // mov d,a    ; 01 010 111
  B00111100,        // inr A
  B01011111,        // mov e,a    ; 01 011 111
  B00111100,        // inr A
  B01100111,        // mov h,a    ; 01 100 111
  B00111100,        // inr A
  B01101111,        // mov l,a    ; 01 101 111
  0343, 38,         // out 38     ; Print the intial register values.
  0166,             // hlt
  //
  //1RRR110
  B00000110, 0,     // mvi b,0  ; Move # to register B.
  //1DDDSSS
  B01111000,        // mov a,b  ; Move register b to each register.
  B00000100,        // inr b 
  B01001000,        // mov c,b
  B00000100,        // inr b 
  B01010000,        // mov d,b
  B00000100,        // inr b 
  B01011000,        // mov e,b
  B00000100,        // inr b 
  B01100000,        // mov h,b
  B00000100,        // inr b 
  B01101000,        // mov l,b
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //1RRR110
  B00001110, 1,     // mvi c,1  ; Move # to register C.
  //1DDDSSS
  B01111001,        // mov a,c  ; Move register c to each register.
  B00001100,        // inr C
  B01000001,        // mov b,c
  B00001100,        // inr C
  B01010001,        // mov d,c
  B00001100,        // inr C
  B01011001,        // mov e,c
  B00001100,        // inr C
  B01100001,        // mov h,c
  B00001100,        // inr C
  B01101001,        // mov l,c
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //1RRR110
  B00010110, 2,     // mvi d,2  ; Move # to register D.
  //1DDDSSS
  B01111010,        // mov a,d  ; Move register d to each register.
  B00010100,        // inr D
  B01000010,        // mov b,d
  B00010100,        // inr D
  B01001010,        // mov c,d
  B00010100,        // inr D
  B01011010,        // mov e,d
  B00010100,        // inr D
  B01100010,        // mov h,d
  B00010100,        // inr D
  B01101010,        // mov l,d
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //1RRR110
  B00011110, 3,     // mvi e,3  ; Move # to register E.
  //1DDDSSS
  B01111011,        // mov a,E  ; Move register e to each register.
  B00011100,        // inr E
  B01000011,        // mov b,E
  B00011100,        // inr E
  B01001011,        // mov c,E
  B00011100,        // inr E
  B01010011,        // mov d,E
  B00011100,        // inr E
  B01100011,        // mov h,E
  B00011100,        // inr E
  B01101011,        // mov l,E
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //1RRR110
  B00100110, 4,     // mvi h,4  ; Move # to register H.
  //1DDDSSS
  B01111100,        // mov a,h  ; Move register h to each register.
  B00100100,        // inr H
  B01000100,        // mov b,h
  B00100100,        // inr H
  B01001100,        // mov c,h
  B00100100,        // inr H
  B01010100,        // mov d,h
  B00100100,        // inr H
  B01011100,        // mov e,h
  B00100100,        // inr H
  B01101100,        // mov l,h
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  //1RRR110
  B00101110, 5,     // mvi l,5  ; Move # to register L.
  //1DDDSSS
  B01111101,        // mov a,l  ; Move register l to each register.
  B00101100,        // inr L
  B01000101,        // mov b,l
  B00101100,        // inr L
  B01001101,        // mov c,l
  B00101100,        // inr L
  B01010101,        // mov d,l
  B00101100,        // inr L
  B01011101,        // mov e,l
  B00101100,        // inr L
  B01100101,        // mov h,l
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  // ------------------------------------------------------------------------------------------
  //
  0041, 0000, 0000, // lxi h,Start  ; lxi_HL lb hb. Load into register H:L = 0000:0000.
  0176,             // mov M,a    ; Move the data in register M(register address H:L), to register A.
  0343, 38,         // out 38     ; Print the Intialized register values.
  0166,             // hlt
  //
  0303, 0000, 0000, // jmp Start    ; Jump back to beginning to avoid endless nops.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// Opcode mvi test program.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                // BEG:       ; Start: Testing opcode mvi.
  //
  0343, 38,         // OUT 30     ; Print the intial register values.
  0166,             // HLT
  //
  // ------------------------------------------------------------------------------------------
  // mvi R,#  00 RRR 110  Move a number (#), which is the next db, to register RRR.
  // mvi A,#  00 111 110  0036
  // mvi B,#  00 000 110  0006
  // mvi C,#  00 001 110  0016
  // mvi D,#  00 010 110  0026
  // mvi E,#  00 011 110  0036
  // mvi H,#  00 100 110  0046
  // mvi L,#  00 101 110  0056
  //                //            ; --------------------------------------
  //                //            ; Intialize register values.
  //
  B00111110, 7,       // mvi A,7    ; Move db to register A.
  B00000110, 0,       // mvi B,0    ; Move db to register B.
  B00001110, 1,       // mvi C,1    ; Move db to register C.
  B00010110, 2,       // mvi D,2    ; Move db to register D.
  B00011110, 3,       // mvi E,3    ; Move db to register E.
  B00100110, 4,       // mvi H,4    ; Move db to register H.
  B00101110, 5,       // mvi L,5    ; Move db to register L.
  //
  0343, 38,         // OUT 30     ; Print the Intialized register values.
  0166,             // HLT
  //
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
//  Other Test Programs
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// I/O program.
// IN this program, terminal output is to the 1602 LCD.

0041, 26, 0,    // LXI M        ; M address is H:L registers. 26 is address of the first data byte.
//
//              // OSTATUS:     ; Check output status availability
0333, 0,        // IN STATUS    ; Input terminal output status
0346, 0200,     // ANI          ; AND register A with 0200.
0302, 3, 0,     // JNZ OSTATUS  ; If status is not ready, jump to OSTATUS and check again.
//
0176,           // MOV A,M      ; Move data at address M(H:L) to A.
0376, 0377,     // CPI          ; Compare A with 0377.
0312, ?, 0,     // JZ EOP       ; If stop code character, jump to halt the program.
//
0323, 1,        // OUT DATA     ; Output data byte to the terminal.
0043,           // INX M        ; Increment
0303, 3, 0,     // JMP INPUT
//
//              // EOP:
0166,           // HLT
//
//              // DATA:
0111            //              ; ASCII I
0040            //              ; ASCII space
0114            //              ; ASCII L
0111            //              ; ASCII I
0113            //              ; ASCII K
0105            //              ; ASCII E
0015            //              ; ASCII CR
0377            //              ; Stop code for CPI instruction.

// -----------------------------------------------------------------------------
// Kill the Bit program.

byte theProgramKtb[] = {
  // ------------------------------------------------------------------
  // Kill the Bit program.
  // Before starting, make sure all the sense switches are in the down position.
  //
  //                Start program.
  0041, 0000, 0000, // LXI H,0    ; Move the lb hb data values into the register pair H(hb):L(lb). Initialize counter
  0026, 0200,       // mvi D,080h ; Move db to register D. Set initial display bit.  080h = 0200 = regD = 10 000 000
  0001, 0036, 0000, // LXI B,0eh  ; Load a(lb:hb) into register B:C. Higher value = faster. Default: 0016 = B:C  = 00 010 000
  //
  //  ; Display bit pattern on upper 8 address lights.
  //                // BEG:
  0166,             // HLT
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  //
  0011,             // DAD B      ; Add B:C to H:L. Set carry bit. Increments the display counter
  // 0322, 0010, 0000, // JNC BEG    ; If carry bit false, jump to lb hb, LDAX instruction start.
  //
  0333, 0377,       // IN 0ffh    ; Check for toggled input, at port 377 (toggle sense switches), that can kill the bit.
  0252,             // XRA D      ; Exclusive OR register with A
  0017,             // RRC        ; Rotate A right (shift byte right 1 bit). Set carry bit. Rotate display right one bit
  0127,             // MOV D,A    ; Move register A to register D. Move data to display reg
  //
  0303, 0010, 0000, // JMP BEG    ; Jump to lb hb, LDAX instruction start.
  // 0000,             // NOP
  // 0166,             // HLT
  // ------------------------------------------------------------------
  0000, 0000, 0000  //       end
};

//  Kill the Bit program:
/*
  Addr Data toggles  Octal Value
  00   00 100 001     041 lxi  : Move the data at lb hb address, into register pair H(hb):L(lb)
  01   00 000 000     000      : lb
  02   00 000 000     000      : hb
  03   00 010 110     026 mvi  : Move db to register D.
  04   10 000 000     200      : db
  05   00 000 001     001 lxi  : Move the lb hb data, into register pair > B:C = hb:lb.
  06   00 001 110     016      : lb = 016
  07   00 000 000     000      : hb = 000
  //                         Make the bit that move across the hb address LED lights.
  08   00 011 010 beg:032 ldax : Load register A with the data at address D:E.
  09   00 011 010     032 ldax
  10   00 011 010     032 ldax
  11   00 011 010     032 ldax
  12   00 001 001     011 dad  : Add B:C to H:L. Set carry bit.
  13   11 010 010     322 jnc  : Jump to address 8(000:010)
  14   00 001 000     010
  15   00 000 000     000
  //
  16   11 011 011     333 in   : Check for the toggled input that can kill the bit.
  17   11 111 111     377
  18   10 101 010     252 xra
  19   00 001 111     017 rrc
  20   01 010 111     127 mov  : Move register A to register D.
  21   11 000 011     303 jmp  : Jump instruction: jmp beg
  22   00 001 000     010      : lb = 8. 00 001 000 = 8. Low order address bits.
  23   00 000 000     000      : hb = 0, to get a 16 bit address(hb:lb): 00 000 000 : 00 001 000 = 8.
  24                      end
*/

// -----------------------------------------------------------------------------
// Sample machine code programs.

// Define a jump loop program byte array.
byte jumpLoopProgram[] = {
  0303, 0006, 0000, // 0 1 2
  0000, 0000, 0000, // 3 4 5
  0303, 0000, 0000  // 6 7 8
};

// Define a jump loop program with NOP instructions.
byte jumpLoopNopProgram[] = {
  0303, 0004, 0000, // 0 1 2
  0000, 0000, 0000, // 3 4 5
  0303, 0000, 0000  // 6 7 8
};

byte TestProgram[] = {
  0303, 0003, 0000, // 0 1 2 JMP to address: 4 
  0041, 0006, 0000, // 3 4 5 LXI_HL lb hb. Load 0000:0006 into register H:L.
  0303, 0000, 0000  // 6 7 8
};

// Define a jump loop program
//    with a halt(HLT binary 01 110 110 = octal 166) instruction,
//    and NOP instructions.
byte jumpHaltLoopProgram[] = {
  0303, 0006, 0000,
  0000, 0000, 0000,
  0166, 0000, 0000,
  0303, 0000, 0000
};

// Sample to test:
//  LXI_HL : Intialize address value in H:L.
//  MOV_HL : Move the data at address H:L, to register A.
//  INX_HL : Increment the address H:L.
//  HLT    : Halt the program.
//  JMP    : Jump back to the move, and loop.
byte lxiNopLoopProgram[] = {
  //                         Start program.
  0000,                   // NOP
  0041, 14, 0000,         // LXI_HL lb hb. Load 0000:14 into register H:L.
  //
  0176,                   // MOV M:address(H:L):data > register A
  0000,                   // NOP
  0043,                   // INX > Increment H:L
  0000,                   // NOP
  0166,                   // HLT
  0000,                   // NOP
  0303, 0006, 0000,       // JMP to 6, jump to the MOV operation.
  //                         Data
  0000, 0101, 0110,       // 3 4 5
  0111, 0000, 0000,       // 6 7 8
  //
  0000, 0000, 0000  //       end
};
// byte NopLxiMovInxHltJmpCpiProgram[] = {
byte NopLxiMovInxHltJmpCpiProgram[] = {
  // ------------------------------------------------------------------
  // Initialize memory read location to memory start.
  // Move the first data byte to the accumulator, which is register A.
  // While not hit the end character (0111)
  //    Increment the memory pointer (H:L).
  //    Move the next data byte to the accumulator.
  //    Halt the process.
  //    Restart the while loop.
  // End while.
  // Restart the program from memory initialization.
  //
  //                Start program.
  0000,             // NOP
  0041, 24, 0000,   // LXI_HL lb hb. Load hb:lb into registers H(hb):L(lb).
  0176,             // MOV M:address(H:L):data > register A
  //
  //                While address:data != 0111
  0376, 0111,             // CPI Compare A with 0111.
  0312, 19, 0000,         // JZ lb hb. If it matches, jump to lb hb (end while)
  0000,                   // NOP
  0166,                   // HLT
  0043,                   // INX > Increment H:L
  0176,                   // MOV M:address(H:L):data > register A
  0000,                   // NOP
  0303, 0005, 0000,       // JMP to the start of the while loop.
  //                End while.
  0000,             // NOP
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address 24.
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  //
  0000, 0000, 0000  //       end
};
byte theProgram[] = {
  /*
//         Code     Octal    Inst Param  Encoding Param  Flags  Description
const byte DAD_BC = 0011; // DAD         00001001          C    Add B:C to H:L. Set carry bit.
//                           DAD  RP     00RP1001          C    Add register pair to HL (16 bit add)
//                           Set carry bit if the addition causes a carry out.
const byte JNC =    0322; // JNC  lb hb  11010010               Jump if carry bit is 0 (false).

   */
  // ------------------------------------------------------------------
  // Initialize memory read location to memory start.
  // Move the first data byte to the accumulator, which is register A.
  // While not hit the end character (0111)
  //    Increment the memory pointer (H:L).
  //    Move the next data byte to the accumulator.
  //    Halt the process.
  //    Restart the while loop.
  // End while.
  // Restart the program from memory initialization.
  //
  //                Start program.
  0000,             // NOP
  0166,             // HLT  : Halt to check the program listing.
  0006, 0776,       // mvi  B,db : Move db to register B.
  0016, 0777,       // mvi  C,db : Move db to register B.
  //                While address:data != 0111
  0376, 0111,             // DAD Add B:C to H:L. Set carry bit.
  0312, 19, 0000,         // JNC lb hb. If carry bit false, jump to lb hb (end while)
  0000,                   // NOP
  0000,                   // NOP
  0000,                   // NOP
  0000,                   // NOP
  0166,                   // HLT
  0043,                   // INX > Increment B
  0000,                   // NOP
  0303, 0005, 0000,       // JMP to the start of the while loop.
  //                End while.
  0000,             // NOP
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address 24.
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  //
  0000, 0000, 0000  //       end
};

byte theProgram[] = {
  // ------------------------------------------------------------------
  // Test: mvi, DAD, JNC
  //                Start program.
  0000,             // NOP
  //                               Set B:C to 0000:1
  0006, 0000,       // mvi  B,db : Move db to register B.
  0016, 0001,       // mvi  C,db : Move db to register C.
  //                               Set
  0041, 0373, 0377, // LXI_HL lb hb. Load into register H:L = 377:373 = 65531.
  //                Until !carry bit {
  0000,               // NOP
  0166,               // HLT
  0011,               // DAD Add B:C to H:L. Set carry bit at: 65535.
  0322,  8, 0000,     // JNC lb hb. If carry bit false, jump to lb hb (end while)
  0303, 17, 0000,     // JMP to the start of the while loop.
  //                }
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address ?
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  0000, 0000, 0000  //       end
};

/*
  00 000 000 = 000 =   0 2^0
  00 000 001 = 002 =   1 2^0
  00 000 010 = 002 =   2 2^1
  00 000 100 = 040 =   4 2^2
  00 001 000 = 010 =   8 2^3
  00 010 000 = 020 =  16 2^4
  00 100 000 = 014 =  32 2^5
  01 000 000 = 014 =  64 2^6
  10 000 000 = 014 = 128 2^7
                     256 2^8
                     512 2^9
                    1024 2^10  1K
                    2048 2^11  2K
                    4096 2^12  4K
                    8192 2^13  8K
                   16384 2^14 16K
                   32768 2^15 32k
                   65535 2^16 64k
*/

// -----------------------------------------------------------------------------

