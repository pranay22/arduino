// -----------------------------------------------------------------------------
//  Programing links

  Bitwise, shift right:
    https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitshiftright/
  Exclusive or (XOR):
    https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwisexor/

/*
  00 000 000 = 000 =   0
  00 000 001 = 002 =   1 2^0
  00 000 010 = 002 =   2 2^1
  00 000 100 = 040 =   4 2^2
  00 001 000 = 010 =   8 2^3
  00 010 000 = 020 =  16 2^4
  00 100 000 = 014 =  32 2^5
  01 000 000 = 014 =  64 2^6
  10 000 000 = 014 = 128 2^7 8 bits store valuse: 0 ... 255
                     256 2^8
                     512 2^9
                    1024 2^10  1K
                    2048 2^11  2K
                    4096 2^12  4K
                    8192 2^13  8K
                   16384 2^14 16K
                   32768 2^15 32k
                   65535 2^16 64k
*/
// -----------------------------------------------------------------------------
// I/O program.
// IN this program, terminal output is to the 1602 LCD.

0041, 26, 0,    // LXI M        ; M is H:L registers. 26 is address of the first data byte.
//
//              // OSTATUS:     ; Check output status availability
0333, 0,        // IN STATUS    ; Input terminal output status
0346, 0200,     // ANI          ; AND register A with 0200.
0302, 3, 0,     // JNZ OSTATUS  ; If status is not ready, jump to OSTATUS and check again.
//
0176,           // MOV A,M      ; Move data at address M(H:L) to A.
0376, 0377,     // CPI          ; Compare A with 0377.
0312, ?, 0,     // JZ EOP       ; If stop code character, jump to halt the program.
//
0323, 1,        // OUT DATA     ; Output data byte to the terminal.
0043,           // INX M        ; Increment
0303, 3, 0,     // JMP INPUT
//
//              // EOP:
0166,           // HLT
//
//              // DATA:
0111            //              ; ASCII I
0040            //              ; ASCII space
0114            //              ; ASCII L
0111            //              ; ASCII I
0113            //              ; ASCII K
0105            //              ; ASCII E
0015            //              ; ASCII CR
0377            //              ; Stop code for CPI instruction.

// -----------------------------------------------------------------------------
// Kill the Bit program.

byte theProgramKtb[] = {
  // ------------------------------------------------------------------
  // Kill the Bit program.
  // Before starting, make sure all the sense switches are in the down position.
  //
  //                Start program.
  0041, 0000, 0000, // LXI H,0    ; Move the lb hb data values into the register pair H(hb):L(lb). Initialize counter
  0026, 0200,       // MVI D,080h ; Move db to register D. Set initial display bit.  080h = 0200 = regD = 10 000 000
  0001, 0036, 0000, // LXI B,0eh  ; Load a(lb:hb) into register B:C. Higher value = faster. Default: 0016 = B:C  = 00 010 000
  //
  //  ; Display bit pattern on upper 8 address lights.
  //                // BEG:
  0166,             // HLT
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  0032,             // LDAX D     ; Move data from address D:E, to register A.
  //
  0011,             // DAD B      ; Add B:C to H:L. Set carry bit. Increments the display counter
  // 0322, 0010, 0000, // JNC BEG    ; If carry bit false, jump to lb hb, LDAX instruction start.
  //
  0333, 0377,       // IN 0ffh    ; Check for toggled input, at port 377 (toggle sense switches), that can kill the bit.
  0252,             // XRA D      ; Exclusive OR register with A
  0017,             // RRC        ; Rotate A right (shift byte right 1 bit). Set carry bit. Rotate display right one bit
  0127,             // MOV D,A    ; Move register A to register D. Move data to display reg
  //
  0303, 0010, 0000, // JMP BEG    ; Jump to lb hb, LDAX instruction start.
  // 0000,             // NOP
  // 0166,             // HLT
  // ------------------------------------------------------------------
  0000, 0000, 0000  //       end
};

//  Kill the Bit program:
/*
  Addr Data toggles  Octal Value
  00   00 100 001     041 lxi  : Move the data at lb hb address, into register pair H(hb):L(lb)
  01   00 000 000     000      : lb
  02   00 000 000     000      : hb
  03   00 010 110     026 mvi  : Move db to register D.
  04   10 000 000     200      : db
  05   00 000 001     001 lxi  : Move the lb hb data, into register pair > B:C = hb:lb.
  06   00 001 110     016      : lb = 016
  07   00 000 000     000      : hb = 000
  //                         Make the bit that move across the hb address LED lights.
  08   00 011 010 beg:032 ldax : Load register A with the data at address D:E.
  09   00 011 010     032 ldax
  10   00 011 010     032 ldax
  11   00 011 010     032 ldax
  12   00 001 001     011 dad  : Add B:C to H:L. Set carry bit.
  13   11 010 010     322 jnc  : Jump to address 8(000:010)
  14   00 001 000     010
  15   00 000 000     000
  //
  16   11 011 011     333 in   : Check for the toggled input that can kill the bit.
  17   11 111 111     377
  18   10 101 010     252 xra
  19   00 001 111     017 rrc
  20   01 010 111     127 mov  : Move register A to register D.
  21   11 000 011     303 jmp  : Jump instruction: jmp beg
  22   00 001 000     010      : lb = 8. 00 001 000 = 8. Low order address bits.
  23   00 000 000     000      : hb = 0, to get a 16 bit address(hb:lb): 00 000 000 : 00 001 000 = 8.
  24                      end
*/

// -----------------------------------------------------------------------------
// Sample machine code programs.

// Define a jump loop program byte array.
byte jumpLoopProgram[] = {
  0303, 0006, 0000, // 0 1 2
  0000, 0000, 0000, // 3 4 5
  0303, 0000, 0000  // 6 7 8
};

// Define a jump loop program with NOP instructions.
byte jumpLoopNopProgram[] = {
  0303, 0004, 0000, // 0 1 2
  0000, 0000, 0000, // 3 4 5
  0303, 0000, 0000  // 6 7 8
};

byte TestProgram[] = {
  0303, 0003, 0000, // 0 1 2 JMP to address: 4 
  0041, 0006, 0000, // 3 4 5 LXI_HL lb hb. Load 0000:0006 into register H:L.
  0303, 0000, 0000  // 6 7 8
};

// Define a jump loop program
//    with a halt(HLT binary 01 110 110 = octal 166) instruction,
//    and NOP instructions.
byte jumpHaltLoopProgram[] = {
  0303, 0006, 0000,
  0000, 0000, 0000,
  0166, 0000, 0000,
  0303, 0000, 0000
};

// Sample to test:
//  LXI_HL : Intialize address value in H:L.
//  MOV_HL : Move the data at address H:L, to register A.
//  INX_HL : Increment the address H:L.
//  HLT    : Halt the program.
//  JMP    : Jump back to the move, and loop.
byte lxiNopLoopProgram[] = {
  //                         Start program.
  0000,                   // NOP
  0041, 14, 0000,         // LXI_HL lb hb. Load 0000:14 into register H:L.
  //
  0176,                   // MOV M:address(H:L):data > register A
  0000,                   // NOP
  0043,                   // INX > Increment H:L
  0000,                   // NOP
  0166,                   // HLT
  0000,                   // NOP
  0303, 0006, 0000,       // JMP to 6, jump to the MOV operation.
  //                         Data
  0000, 0101, 0110,       // 3 4 5
  0111, 0000, 0000,       // 6 7 8
  //
  0000, 0000, 0000  //       end
};
// byte NopLxiMovInxHltJmpCpiProgram[] = {
byte NopLxiMovInxHltJmpCpiProgram[] = {
  // ------------------------------------------------------------------
  // Initialize memory read location to memory start.
  // Move the first data byte to the accumulator, which is register A.
  // While not hit the end character (0111)
  //    Increment the memory pointer (H:L).
  //    Move the next data byte to the accumulator.
  //    Halt the process.
  //    Restart the while loop.
  // End while.
  // Restart the program from memory initialization.
  //
  //                Start program.
  0000,             // NOP
  0041, 24, 0000,   // LXI_HL lb hb. Load hb:lb into registers H(hb):L(lb).
  0176,             // MOV M:address(H:L):data > register A
  //
  //                While address:data != 0111
  0376, 0111,             // CPI Compare A with 0111.
  0312, 19, 0000,         // JZ lb hb. If it matches, jump to lb hb (end while)
  0000,                   // NOP
  0166,                   // HLT
  0043,                   // INX > Increment H:L
  0176,                   // MOV M:address(H:L):data > register A
  0000,                   // NOP
  0303, 0005, 0000,       // JMP to the start of the while loop.
  //                End while.
  0000,             // NOP
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address 24.
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  //
  0000, 0000, 0000  //       end
};
byte theProgram[] = {
  /*
//         Code     Octal    Inst Param  Encoding Param  Flags  Description
const byte DAD_BC = 0011; // DAD         00001001          C    Add B:C to H:L. Set carry bit.
//                           DAD  RP     00RP1001          C    Add register pair to HL (16 bit add)
//                           Set carry bit if the addition causes a carry out.
const byte JNC =    0322; // JNC  lb hb  11010010               Jump if carry bit is 0 (false).

   */
  // ------------------------------------------------------------------
  // Initialize memory read location to memory start.
  // Move the first data byte to the accumulator, which is register A.
  // While not hit the end character (0111)
  //    Increment the memory pointer (H:L).
  //    Move the next data byte to the accumulator.
  //    Halt the process.
  //    Restart the while loop.
  // End while.
  // Restart the program from memory initialization.
  //
  //                Start program.
  0000,             // NOP
  0166,             // HLT  : Halt to check the program listing.
  0006, 0776,       // MVI  B,db : Move db to register B.
  0016, 0777,       // MVI  C,db : Move db to register B.
  //                While address:data != 0111
  0376, 0111,             // DAD Add B:C to H:L. Set carry bit.
  0312, 19, 0000,         // JNC lb hb. If carry bit false, jump to lb hb (end while)
  0000,                   // NOP
  0000,                   // NOP
  0000,                   // NOP
  0000,                   // NOP
  0166,                   // HLT
  0043,                   // INX > Increment B
  0000,                   // NOP
  0303, 0005, 0000,       // JMP to the start of the while loop.
  //                End while.
  0000,             // NOP
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address 24.
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  //
  0000, 0000, 0000  //       end
};

byte theProgram[] = {
  // ------------------------------------------------------------------
  // Test: MVI, DAD, JNC
  //                Start program.
  0000,             // NOP
  //                               Set B:C to 0000:1
  0006, 0000,       // MVI  B,db : Move db to register B.
  0016, 0001,       // MVI  C,db : Move db to register C.
  //                               Set
  0041, 0373, 0377, // LXI_HL lb hb. Load into register H:L = 377:373 = 65531.
  //                Until !carry bit {
  0000,               // NOP
  0166,               // HLT
  0011,               // DAD Add B:C to H:L. Set carry bit at: 65535.
  0322,  8, 0000,     // JNC lb hb. If carry bit false, jump to lb hb (end while)
  0303, 17, 0000,     // JMP to the start of the while loop.
  //                }
  0166,             // HLT
  0000,             // NOP
  0303, 1, 0000,    // JMP to 1. Restart: jump to program start.
  // ------------------------------------------------------------------
  //                Data, starts at address ?
  0000, 0101, 0001, // 5 6 7
  0010, 0110, 0111, // 8 9 0
  0000, 0000, 0000  //       end
};

/*
  00 000 000 = 000 =   0 2^0
  00 000 001 = 002 =   1 2^0
  00 000 010 = 002 =   2 2^1
  00 000 100 = 040 =   4 2^2
  00 001 000 = 010 =   8 2^3
  00 010 000 = 020 =  16 2^4
  00 100 000 = 014 =  32 2^5
  01 000 000 = 014 =  64 2^6
  10 000 000 = 014 = 128 2^7
                     256 2^8
                     512 2^9
                    1024 2^10  1K
                    2048 2^11  2K
                    4096 2^12  4K
                    8192 2^13  8K
                   16384 2^14 16K
                   32768 2^15 32k
                   65535 2^16 64k
*/

// -----------------------------------------------------------------------------

