// -----------------------------------------------------------------------------
/*
  Use a Micro SD Card Module to save and load binary 8080 machine language programs.

  The arrry, theProgram, is a binary 8080 machine language program.
  Write it to the SD card.
  Read it from the SD card and compare it with the original array.

  SPI reference: https://www.arduino.cc/en/Reference/SPI
  SD card library reference: https://www.arduino.cc/en/reference/SD
*/

// #define INCLUDE_LCD 1
#define INCLUDE_CLOCK 1
#define CLOCK_MESSAGES 1
// #define INCLUDE_SDCARD 1
#define LOG_MESSAGES 1

// -----------------------------------------------------------------------------
// For the clock board.
#ifdef INCLUDE_CLOCK

#include "RTClib.h"

RTC_DS3231 rtc;
DateTime now;
/*
  Connect DS3231 Clock, and the LCD display, pins to the Nano:
  + VCC to Nano 5v, note, also works with 3.3v, example: NodeMCU.
  + GND to Nano ground.
  + SDA to Nano D4 (pin 4), same on Uno.
  + SCL to Nano D5 (pin 5), same on Uno.
*/
#endif

// -----------------------------------------------------------------------------
// SD Card module uses SPI.
#ifdef INCLUDE_SDCARD

#include <SPI.h>
#include <SD.h>

// SD Card Module is an SPI slave device.
//  CS (chip/slave select)     to Nano pin 10 (SS pin). Can be any digital pin on the master(Nano) to enable and disable this device on the SPI bus.
// SCK, MOSI, MISO are the SPI hardware pins are declared in the SPI library.
//  SCK (serial clock)         to Nano pin 13 SPI: accepts clock pulses which synchronize data transmission generated by Arduino
//  MOSI (master out slave in) to Nano pin 11 SPI: input to the Micro SD Card Module.
//  MISO (master in slave Out) to Nano pin 12 SPI: output from the Micro SD Card Module.
//  VCC (3.3V or 5V)           to Nano pin 5V+
//  GND (ground)               to Nano pin ground

// The CS pin is the only one that is not really fixed as any of the Arduino digital pin.
const int csPin = 10;  // SD Card module is connected to Nano pin 10.
File myFile;

// Test file name.
// Files are created using uppercase: F1.TXT.
String theFilename = "f1.txt";

#endif

// -----------------------------------------------------------------------------
// Test program to use in this program. The program tests the 16 bit add opcode, dad.

byte theProgram[] = {
  //                //            ; --------------------------------------
  //                //            ; Test opcode dad.
  //                //            ; --------------------------------------
  //                // Start:     ; Intialize register values.
  B00111110, 6,     // mvi a,6    ; Move numbers to registers.
  B00000110, 0,     // mvi b,0
  B00001110, 1,     // mvi c,1
  B00010110, 2,     // mvi d,2
  B00011110, 3,     // mvi e,3
  B00100110, 4,     // mvi h,0
  B00101110, 5,     // mvi l,0
  0343, 38,         // out 38     ; Print the Intialized register values.
  //                //            ; --------------------------------------
  //0RP1001
  B00001001,        // dad b      ; Add register pair B:C to H:L.
  0343, 36,         // out 36     ; Print register pair, H:L.
  B00011001,        // dad d      ; Add register pair D:E to H:L.
  0343, 36,         // out 36     ; Print register pair, H:L.
  //                //            ; --------------------------------------
  0166,             // hlt
  0303, 0000, 0000, // jmp Start  ; Jump back to beginning.
  0000              //            ; End.
};

// -----------------------------------------------------------------------------
// Memory definitions

const int memoryBytes = 256;
byte memoryData[memoryBytes];
unsigned int programCounter = 0;     // Program address value

// -----------------------------------------------------------------------------
// Memory Functions

char charBuffer[17];
byte zeroByte = B00000000;

void initMemoryToZero() {
  Serial.println(F("+ Initialize all memory bytes to zero."));
  for (int i = 0; i < memoryBytes; i++) {
    memoryData[i] = zeroByte;
  }
}

void copyByteArrayToMemory(byte btyeArray[], int arraySize) {
  Serial.println(F("+ Copy the program into the computer's memory array."));
  for (int i = 0; i < arraySize; i++) {
    memoryData[i] = btyeArray[i];
  }
  Serial.println(F("+ Copied."));
}

void listByteArray(byte btyeArray[], int arraySize) {
  Serial.println(F("+ List the program."));
  Serial.println(F("++   Address:       Data value"));
  for (int i = 0; i < arraySize; i++) {
    Serial.print(F("+ Addr: "));
    sprintf(charBuffer, "%4d:", i);
    Serial.print(charBuffer);
    Serial.print(F(" Data: "));
    printData(btyeArray[i]);
    Serial.println("");
  }
  Serial.println(F("+ End of listing."));
}

// -----------------------------------------------------------------------------
// Output: log messages and Front Panel LED data lights.

void printByte(byte b) {
  for (int i = 7; i >= 0; i--)
    Serial.print(bitRead(b, i));
}
void printWord(int theValue) {
  String sValue = String(theValue, BIN);
  for (int i = 1; i <= 16 - sValue.length(); i++) {
    Serial.print("0");
  }
  Serial.print(sValue);
}

void printOctal(byte b) {
  String sOctal = String(b, OCT);
  for (int i = 1; i <= 3 - sOctal.length(); i++) {
    Serial.print("0");
  }
  Serial.print(sOctal);
}

void printData(byte theByte) {
  sprintf(charBuffer, "%3d = ", theByte);
  Serial.print(charBuffer);
  printOctal(theByte);
  Serial.print(F(" = "));
  printByte(theByte);
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

// Write Program memory to a file.
#ifdef INCLUDE_SDCARD

// -----------------------------
// Write Program Memory To File

void writeProgramMemoryToFile(String theFilename) {
#ifdef LOG_MESSAGES
  Serial.println("+ Write program memory to a new file named: ");
  Serial.print(theFilename);
  Serial.println("+ Check if file exists. ");
#endif
  if (SD.exists(theFilename)) {
    SD.remove(theFilename);
    // Serial.println("++ Exists, so it was deleted.");
  } else {
    // Serial.println("++ Doesn't exist.");
  }
  myFile = SD.open(theFilename, FILE_WRITE);
  if (!myFile) {
    Serial.print("- Error opening file: ");
    Serial.println(theFilename);
    return; // When used in setup(), causes jump to loop().
  }
#ifdef LOG_MESSAGES
  Serial.println("++ New file opened.");
  Serial.println("++ Write binary memory to the file.");
#endif
  for (int i = 0; i < memoryBytes; i++) {
    myFile.write(memoryData[i]);
  }
  myFile.close();
  Serial.println("+ Completed, file closed.");
}

// -----------------------------
// Read Program File Into Memory

byte fileMemoryData[memoryBytes];

void readProgramFileIntoMemory(String theFilename) {
  Serial.println("+ Read a file into program memory, file named: ");
  Serial.print(theFilename);
  Serial.println("+ Check if file exists. ");
  if (SD.exists(theFilename)) {
    Serial.println("++ Exists, so it can be read.");
  } else {
    Serial.println("++ Doesn't exist, cannot read.");
    return;
  }
  myFile = SD.open(theFilename);
  if (!myFile) {
    Serial.print("- Error opening file: ");
    Serial.println(theFilename);
    return;
  }
  int i = 0;
  while (myFile.available()) {
    // Reads one character at a time.
    fileMemoryData[i] = myFile.read();
    // Print Binary:Octal:Decimal values.
    Serial.print("B");
    printByte(fileMemoryData[i]);
    Serial.print(":");
    printOctal (fileMemoryData[i]);
    Serial.print(":");
    Serial.println(fileMemoryData[i], DEC);
    i++;
    if (i > memoryBytes) {
      Serial.println("-+ Warning, file contains more data bytes than abailable memory.");
    }
  }
  myFile.close();
  Serial.println("+ File closed.");
}
#endif

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// 1602 LCD
#ifdef INCLUDE_LCD

#include<Wire.h>
#include<LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 20, 4);

String theLine = "";
int displayColumns = 16;
void displayPrintln(int theRow, String theString) {
  // To overwrite anything on the current line.
  String printString = theString;
  int theRest = displayColumns - theString.length();
  if (theRest < 0) {
    // Shorten to the display column length.
    printString = theString.substring(0, displayColumns);
  } else {
    // Buffer with spaces to the end of line.
    while (theRest < displayColumns) {
      printString = printString + " ";
      theRest++;
    }
  }
  lcd.setCursor(0, theRow);
  lcd.print(printString);
}

void readyLcd() {
  lcd.init();
  lcd.backlight();
  //                1234567890123456
  displayPrintln(0, "Altair 101");
  theLine = "LCD ready...";
  displayPrintln(1, theLine);
  // delay(3000);
  // lcd.clear();
}
#endif

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// DS3231 Clock
#ifdef INCLUDE_CLOCK

int theCursor;
const int printRowClockDate = 0;
const int printColClockDate = 0;
const int printRowClockPulse = 0;
const int thePrintColHour = 8;
const int thePrintColMin = thePrintColHour + 3;
const int thePrintColSec = thePrintColMin + 3;

int theCounterSeconds = 0;
int theCounterMinutes = 0;
int theCounterHours = 0;

void syncCountWithClock() {
  now = rtc.now();
  theCounterHours = now.hour();
  theCounterMinutes = now.minute();
  theCounterSeconds = now.second();
  //
#ifdef CLOCK_MESSAGES
  Serial.println("+ syncCountWithClock, current time:");
  Serial.print(" theCounterHours=");
  Serial.println(theCounterHours);
  Serial.print(" theCounterMinutes=");
  Serial.println(theCounterMinutes);
  Serial.print(" theCounterSeconds=");
  Serial.println(theCounterSeconds);
#endif
}

void processClockNow() {
  now = rtc.now();
  if (now.second() != theCounterSeconds) {
    // When the clock second value changes, that's a clock second pulse.
    theCounterSeconds = now.second();
    clockPulseSecond();
    if (theCounterSeconds == 0) {
      // When the clock second value changes to zero, that's a clock minute pulse.
      theCounterMinutes = now.minute();
      clockPulseMinute();
      if (theCounterMinutes == 0) {
        // When the clock minute value changes to zero, that's a clock hour pulse.
        theCounterHours = now.hour();
        clockPulseHour();
      }
    }
  }
}

int theHour = 0;
void clockPulseHour() {
  // 12 hour AM/PM clock. Use 3, rather than 15.
  if (theCounterHours > 12) {
    theHour = theCounterHours - 12;
  } else if (theCounterHours == 0) {
    theHour = 12; // 12 midnight, 12am
  } else {
    theHour = theCounterHours;
  }
#ifdef CLOCK_MESSAGES
  Serial.print("++ clockPulseHour(), theCounterHours= ");
  Serial.print(theCounterHours);
  Serial.print(", theHour= ");
  Serial.println(theHour);
#endif
  // sendByte2nano(theHour);
}
void clockPulseMinute() {
#ifdef CLOCK_MESSAGES
  Serial.println("");
  Serial.print("+ clockPulseMinute(), theCounterMinutes= ");
  Serial.println(theCounterMinutes);
  Serial.print("+ theCounterSeconds > ");
#endif
  // sevseg.setNumber(theCounterMinutes);
}
void clockPulseSecond() {
#ifdef CLOCK_MESSAGES
  if (theCounterSeconds == 21 || theCounterSeconds == 41) {
    Serial.println("");
    Serial.print("+ theCounterSeconds > ");
  }
  Serial.print(theCounterSeconds);
  Serial.print(".");
#endif
  // sevseg.setNumber(theCounterSeconds);
}

#endif

// -----------------------------------------------------------------------------
char dayOfTheWeek[7][1] = {"S", "M", "T", "W", "T", "F", "S"};
#ifdef INCLUDE_CLOCK
#ifdef INCLUDE_LCD

void printClockDate() {
  theCursor = printColClockDate;
  lcd.setCursor(theCursor, printRowClockDate);    // Column, Row
  lcd.print(dayOfTheWeek[now.dayOfTheWeek()]);
  // ---
  lcd.setCursor(++theCursor, printRowClockDate);    // Column, Row
  lcd.print(":");
  printClockByte(++theCursor, printRowClockDate, now.month());
  // ---
  theCursor = theCursor + 2;
  lcd.print("/");
  printClockByte(++theCursor, printRowClockDate, now.day());
}

void printClockByte(int theColumn, int theRow, char theByte) {
  int iByte = (char)theByte;
  lcd.setCursor(theColumn, theRow);    // Column, Row
  if (iByte < 10) {
    lcd.print("0");
    lcd.setCursor(theColumn + 1, theRow);
  }
  lcd.print(iByte);
}

#endif
#endif

// -----------------------------------------------------------------------------
void setup() {
  Serial.begin(115200);
  // Give the serial connection time to start before the first print.
  delay(1000);
  Serial.println(""); // Newline after garbage characters.
  Serial.println("+++ Setup.");

  // ----------------------------------------------------
#ifdef INCLUDE_LCD
  readyLcd();
  Serial.println(F("+ LCD ready for output."));
#endif

  // ----------------------------------------------------
#ifdef INCLUDE_CLOCK
  // RTC: Real Time Clock
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    while (1);
  }
  if (rtc.lostPower()) {
    Serial.println("RTC lost power, need to reset the time.");
    rtc.adjust(DateTime(2005, 11, 12, 0, 0, 0));
  }
  //
  // Set for testing.
  // rtc.adjust(DateTime(2019, 10, 22, 23, 59, 56));
  // delay(100);
  //
  syncCountWithClock();
  Serial.println("+ Clock set and synched with program variables.");
#endif

#ifdef INCLUDE_SDCARD
  // ----------------------------------------------------
  int programSize = sizeof(theProgram);
  // List a program.
  listByteArray(theProgram, programSize);
  // Load a program.
  copyByteArrayToMemory(theProgram, programSize);

  // ----------------------------------------------------
  // Note, csPin is optional. The default is the hardware SS line (pin 10) of the SPI bus.
  // If using pin, other than 10, add: pinMode(otherPin, OUTPUT);
  // The pin connected to the chip select pin (CS) of the SD card.
  if (!SD.begin(csPin)) {
    Serial.println("- Error initializing SD card.");
    return; // When used in setup(), causes jump to loop().
  }
  Serial.println("+ SD card initialized.");
  //
  // Write the file to the SD card.
  // writeProgramMemoryToFile("dad.asm");
  //
  // Read the SD card file data into an array.
  readProgramFileIntoMemory("dad.asm");
#endif

  // -------------------------------
  Serial.println("+++ Go to loop.");

#ifdef INCLUDE_LCD
  Serial.print("+ theCounterSeconds > ");
#endif
}

// -----------------------------------------------------------------------------
// Device Loop
#ifdef INCLUDE_CLOCK
static unsigned long clockTimer = millis();
#endif
void loop() {

#ifdef INCLUDE_CLOCK
  // Check the clock and pulse when the clock's second value changes.
  if (millis() - clockTimer >= 200) {
    processClockNow();
    clockTimer = millis();
  }
#else
  Serial.println("+ Looping");
  delay(10000);
#endif

}
// -----------------------------------------------------------------------------
