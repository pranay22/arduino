adi:11000110:ADI #    11 000 110  3  Add immediate number to register A, set: ZSCPA.
ani:11100110:ANI #    11 100 110  2  AND # (immediate db) with register A.
call:11001101:CALL a   11 001 101  3  Unconditional subroutine call. Push current address onto the stack and jump the subroutine address.
cmp:10111SSS:CMP S    10 111 SSS  1  Compare register(S) with register A, then set flags. If S=A, set Zero bit to 1. If S>A, Carry bit = 1. If S<A, Carry bit = 0.
cmpa:10111111:
cmpb:10111000:
cmpc:10111001:
cmpd:10111010:
cmpe:10111011:
cmph:10111100:
cmpl:10111101:
cpi:11111110:CPI #    11 111 110  2  Compare # to A. Store true or false into flagZeroBit.
dad:00RP1001:DAD RP   00 RP1 001  1  16 bit add. Add register pair(RP: B:C or D:E) to H:L, into H:L. And set carry bit.
dadb:00001001:
dadd:00101001:
dcr:00DDD101:DCR D    00 DDD 101  1  Decrement a register. To do, set flags: ZSPA.
dcra:00111101:
dcrb:00000101:
dcrc:00001101:
dcrd:00010101:
dcre:00011101:
dcrh:00100101:
dcrl:00101101:
hlt:01110110:HLT      01 110 110  1  Halt processor.
in:11011011:IN pa    11 011 011  2  Read port a data into the accumulator. Example, a=0377 is the sense switches.
inr:00DDD100:INR D    00 DDD 100  1  Increment register DDD. To do, set flags: ZSPA.
inra:00111100:INR D    00 DDD 100  1  Increment register DDD. To do, set flags: ZSPA.
inrb:00000100:
inrc:00001100:
inrd:00010100:
inre:00011100:
inrh:00100100:
inrl:00101100:
inrm:00101100:
inx:00RP0011:INX RP   00 RP0 011  1  Increment a register pair(16 bit value): B:C, D:E, H:L. To do: increment the stack pointer.
inxb:00000011:
inxd:00010011:
inxh:00100011:
jmp:11000011:JMP a    11 000 011  3  Unconditional jump.
jnz:11000010:JNZ a    11 000 010  3  Jump to a, if Zero bit flag is not set (equals 0).
jz:11001010:JZ a     11 001 010  3  Jump to a, if zero bit flag is set (equals 1).
jnc:11010010:JNC a    11 010 010  3  Jump to a, if Carry bit flag is not set (equals 0).
jc:11011010:JC a     11 011 010  3  Jump to a, if Carry bit flag is set (equals 1).
lda:00111010:LDA a    00 111 010  3  Load register A with data from the address, a(hb:lb).
ldax:00RP1010:LDAX RP  00 RP1 010  1  Load data value at the register pair address (B:C(RP=00) or D:E(RP=01)), into register A.
ldaxb:00001010:
ldaxd:00011010:
lxi:00RP0001:LXI RP,a 00 RP0 001  3  Move the data at the address, a(lb hb), into register pair: B:C, D:E, or H:L. To do: move data to the stack pointer address.
lxib:00000001:
lxid:00010001:
lxih:00100001:
lxisp:00110001:
mov:01DDDSSS:MOV D,S  01 DDD SSS  1  Move source register data, to the destination register. If source(S) is M(110), move data from address H:L, to D.
movab:01111000:
movac:01111001:
movad:01111010:
movae:01111011:
movah:01111100:
moval:01111101:
movba:01000111:
movbc:01000001:
movbd:01000010:
movbe:01000011:
movbh:01000100:
movbl:01000101:
movca:01001111:
movcb:01001000:
movcd:01001010:
movce:01001011:
movch:01001100:
movcl:01001101:
movda:01010111:
movdb:01010000:
movdc:01010001:
movde:01010011:
movdh:01010100:
movdl:01010101:
movea:01011111:
moveb:01011000:
movec:01011001:
moved:01011010:
moveh:01011100:
movel:01011101:
movha:01100111:
movhb:01100000:
movhc:01100001:
movhd:01100010:
movhe:01100011:
movhl:01100101:
movla:01101111:
movlb:01101000:
movlc:01101001:
movld:01101010:
movle:01101011:
movlh:01101100:
movam:01111110:
movbm:01000110:
movcm:01001110:
movdm:01010110:
movem:01011110:
movhm:01100110:
movlm:01101110:
mvia:00RRR110:MVI R,#  00 RRR 110  2  Move a number (#, db) to a register.
mvib:00000110:
mvic:00001110:
mvid:00010110:
mvie:00011110:
mvih:00100110:
mvil:00101110:
nop:00000000:NOP      00 000 000  1  No operation. I added a delay: delay(100).
ora:10110SSS:ORA S    10 110 SSS  1  OR register S, with register A.
oraa:10110111:
orab:10110000:
orac:10110001:
orad:10110010:
orae:10110011:
orah:10110100:
oral:10110101:
oram:10110110:
out:11100011:OUT pa   11 010 011  2  Write the accumulator data out to port a. I'm using this opcode to write custom log messages such as echoing the registers.
ret:11001001:RET      11 001 001  1  Unconditional return from subroutine. Pop the call address from the stack and continue to the next address.
rlc:00000111:RLC      00 000 111  1  Rotate accumulator left by shift left 1 bit, and wrapping the first bit to the last position. Need to handle carry bit (CY = prev bit 7).
rrc:00001111:RRC      00 001 111  1  Rotate accumulator right by shift right 1 bit, and wrapping the last bit to the first position. Need to handle carry bit (CY = prev bit 0).
shld:00100010:SHLD a   00 100 010  3  Store data value from memory location: a(address hb:lb), to register L. Store value at: a + 1, to register H.
sta:00110010:STA a    00 110 010  3  Store register A to the address, a(hb:lb).
sui:11010110:SUI #    11 010 110  3  Subtract immediate number from register A, set ZSCPA.
xra:10101111:XRA R    10 101 SSS  1  Exclusive OR, the register(R) with register A.
xrab:10101000:
xrac:10101001:
xrad:10101010:
xrae:10101011:
xrah:10101100:
xral:10101101:
