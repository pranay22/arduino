// Opcode table of information
// Opcode:Byte-Description
// Note, a comment with a second ":" will cause an error in the sort classes. Even though, the sorted listings work fine.

// Opcodes ordered as is.
// Binary             Opcode   Binary   Cycles Description
// -------------------------------------------------------

// -----------------------------------------------------------------------------
// Operation codes

nop:00000000:NOP      00 000 000  1  No operation. I added a delay: delay(100).
hlt:01110110:HLT      01 110 110  1  Halt processor.
call:11001101:CALL a   11 001 101  3  Unconditional subroutine call. Push current address onto the stack and jump the subroutine address.
ret:11001001:RET      11 001 001  1  Unconditional return from subroutine. Pop the call address from the stack and continue to the next address.

in:11011011:IN pa    11 011 011  2  Read port a data into the accumulator. Example, a=0377 is the sense switches.
out:11100011:OUT pa   11 010 011  2  Write the accumulator data out to port a. I'm using this opcode to write custom log messages such as echoing the registers.

// -----------------------------------------------------------------------------
// Compare and branching

cmp:10111SSS:CMP S    10 111 SSS  1  Compare register(S: B,C,D,E,H,L, or M) with register A, then set flags. If S==A, ZeroBit=1 & CarryBit=0. If S!=A, ZeroBit=0. If S>A, CarryBit=1. If S<A, CarryBit=0.
cmpa:10111111:
cmpb:10111000:
cmpc:10111001:
cmpd:10111010:
cmpe:10111011:
cmph:10111100:
cmpl:10111101:
cmpm:10111110:
cpi:11111110:CPI #    11 111 110  2  Compare #(immediate value) to A. If #==A, ZeroBit=1 & CarryBit=0. If #!=A, ZeroBit=0. If #>A, CarryBit=1. If #<A, CarryBit=0.

jnz:11000010:JNZ a    11 000 010  3  Jump to a, if Zero bit flag is not set (equals 0).
jz:11001010:JZ a     11 001 010  3  Jump to a, if zero bit flag is set (equals 1).
jnc:11010010:JNC a    11 010 010  3  Jump to a, if Carry bit flag is not set (equals 0).
jc:11011010:JC a     11 011 010  3  Jump to a, if Carry bit flag is set (equals 1).
jmp:11000011:JMP a    11 000 011  3  Unconditional jump to address a.

// -----------------------------------------------------------------------------
// Moving data around

sta:00110010:STA a    00 110 010  3  A -> (adr): Store register A to the address, a(hb:lb).
lda:00111010:LDA a    00 111 010  3  (adr) -> A: Load register A with data from the address, a(hb:lb).
shld:00100010:SHLD a   00 100 010  3  L->(adr);H->(adr+1): Store register data values to memory locations: register L a(address hb:lb). Store register H to: a + 1.
lhld:00101010:LHLD a   00 101 010  3  (adr)->L;(adr+1)->H: Load registers H and L (H:L) with address values a and a+1.
ldax:00RP1010:LDAX RP  00 RP1 010  1  Load data value at the register pair address (B:C(RP=00) or D:E(RP=01)), into register A.
ldaxb:00001010:|(BC) -> A
ldaxd:00011010:|(DE) -> D
lxi:00RP0001:LXI RP,a 00 RP0 001  3  byte3->R,byte2->P:Move the data at the address, a(lb hb), into register pair: B:C, D:E, or H:L. To do: move data to the stack pointer address.
lxib:00000001:|byte 3 -> B, byte 2 -> C
lxid:00010001:|byte 3 -> D, byte 2 -> E
lxih:00100001:|byte 3 -> H, byte 2 -> L
lxisp:00110001:
mov:01DDDSSS:MOV D,S  01 DDD SSS  1  Move source register(SSS) data, to the destination(DDD) register(A,B,C,D,E,H, or L). If source(S) is M(110), move data from address H:L, to destination(D).
movab:01111000:
movac:01111001:
movad:01111010:
movae:01111011:
movah:01111100:
moval:01111101:
movba:01000111:
movbc:01000001:
movbd:01000010:
movbe:01000011:
movbh:01000100:
movbl:01000101:
movca:01001111:
movcb:01001000:
movcd:01001010:
movce:01001011:
movch:01001100:
movcl:01001101:
movda:01010111:
movdb:01010000:
movdc:01010001:
movde:01010011:
movdh:01010100:
movdl:01010101:
movea:01011111:
moveb:01011000:
movec:01011001:
moved:01011010:
moveh:01011100:
movel:01011101:
movha:01100111:
movhb:01100000:
movhc:01100001:
movhd:01100010:
movhe:01100011:
movhl:01100101:
movla:01101111:
movlb:01101000:
movlc:01101001:
movld:01101010:
movle:01101011:
movlh:01101100:
movam:01111110:
movbm:01000110:
movcm:01001110:
movdm:01010110:
movem:01011110:
movhm:01100110:
movlm:01101110:
mvi:00RRR110:MVI R,#  00 RRR 110  2  Move #(immediate value) to a register (R).
mvia:00111110:
mvib:00000110:
mvic:00001110:
mvid:00010110:
mvie:00011110:
mvih:00100110:
mvil:00101110:

// -----------------------------------------------------------------------------
// Math related

dcr:00DDD101:DCR D    00 DDD 101  1  Decrement a register DDD(A,B,C,D,E,H, or L). To do, set flags: ZSPA.
dcra:00111101:|A-1 -> A
dcrb:00000101:|B-1 -> B
dcrc:00001101:|C-1 -> C
dcrd:00010101:|D-1 -> D
dcre:00011101:|E-1 -> E
dcrh:00100101:|H-1 -> H
dcrl:00101101:|L-1 -> L
inr:00DDD100:INR D    00 DDD 100  1  Increment register DDD(A,B,C,D,E,H, or L). To do, set flags: ZSPA.
inra:00111100:|A+1 -> A
inrb:00000100:|B+1 -> B
inrc:00001100:|C+1 -> C
inrd:00010100:|D+1 -> D
inre:00011100:|E+1 -> E
inrh:00100100:|H+1 -> H
inrl:00101100:|L+1 -> L
inrm:00101100:|(HL)+1 -> (HL)

inx:00RP0011:INX RP   00 RP0 011  1  Increment a register pair(16 bit value): B:C, D:E, H:L. To do: increment the stack pointer.
inxb:00000011:|BC = BC+1
inxd:00010011:|DE = DE+1
inxh:00100011:|HL = HL+1
dcx:00RP1011:DCX RP   00 RP1 011  1  Decrement a register pair(16 bit value): B:C, D:E, H:L.
dcxb:00001011:|BC = BC-1
dcxd:00011011:|DE = DE-1
dcxh:00101011:|HL = HL-1

adi:11000110:ADI #    11 000 110  3  Add #(immediate value) to register A, set: ZSCPA.
sui:11010110:SUI #    11 010 110  3  Subtract immediate number from register A, set ZSCPA.
dad:00RP1001:DAD RP   00 RP1 001  1  16 bit add. Add register pair(RP: B:C or D:E) to H:L, into H:L. And set carry bit.
dadb:00001001:|HL = HL + BC
dadd:00101001:|HL = HL + DE

// -----------------------------------------------------------------------------
// Bit and logic applied to a register or byte.

ani:11100110:ANI #    11 100 110  2  AND #(immediate value) with register A.
ora:10110SSS:ORA S    10 110 SSS  1  OR register S, with register A.
oraa:10110111:
orab:10110000:
orac:10110001:
orad:10110010:
orae:10110011:
orah:10110100:
oral:10110101:
oram:10110110:
xra:10101SSS:XRA R    10 101 SSS  1  Exclusive OR, the register(R) with register A.
xrab:10101000:
xrac:10101001:
xrad:10101010:
xrae:10101011:
xrah:10101100:
xral:10101101:

rlc:00000111:RLC      00 000 111  1  Rotate accumulator left by shift left 1 bit, and wrapping the first bit to the last position. Need to handle carry bit (CY = prev bit 7).
rrc:00001111:RRC      00 001 111  1  Rotate accumulator right by shift right 1 bit, and wrapping the last bit to the first position. Need to handle carry bit (CY = prev bit 0).

// -----------------------------------------------------------------------------
// eof